---
import ChatWidget from "../components/ChatWidget";
import CommandMenu from "../components/CommandMenu";
import { Toaster } from "sonner";

interface Props {
  title?: string;
  description?: string;
  showChatWidget?: boolean;
  showCommandMenu?: boolean;
  showToaster?: boolean;
}

const {
  title = "Gabor Flandorffer — Senior Full-Stack Developer & Automation Specialist",
  description = "11+ years building scalable solutions with Python, Django, TypeScript, and automation tools. Based in Medellín.",
  showChatWidget = false,
  showCommandMenu = false,
  showToaster = false,
} = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{title}</title>
    <meta name="description" content={description} />

    <!-- SEO / OG Tags -->
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://gabor.dev" />
    <meta property="og:image" content="/images/profile/Gabor-Flandorffer-Profile.jpg" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content={title} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:image" content="/images/profile/Gabor-Flandorffer-Profile.jpg" />

    <!-- Performance: Preconnect to font providers -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

    <!-- Performance: Preload critical fonts -->
    <link
        rel="preload"
        as="style"
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@400;500;600&family=Space+Grotesk:wght@600&display=swap"
        media="print"
        onload="this.media='all'"
      />
    <noscript
      ><link
        rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@400;500;600&family=Space+Grotesk:wght@600&display=swap"
      /></noscript
    >

    <link rel="icon" type="image/x-icon" href="/images/profile/favicon.ico" />
    <link rel="apple-touch-icon" href="/images/profile/favicon.ico" />
    <link rel="manifest" href="/manifest.json" />
  </head>
  <body>
    <!-- Custom Cursor -->
    <div class="custom-cursor"></div>

    <!-- Mouse Spotlight -->
    <div class="mouse-spotlight"></div>

    <!-- Scroll Progress Bar -->
    <div id="scroll-progress" class="scroll-progress"></div>

    <slot />

    <!-- WhatsApp Floating Button -->
    <a
      href="https://wa.me/491789752993?text=Hi%20Gabor!%20I%20saw%20your%20portfolio%20and%20I'd%20like%20to%20chat."
      target="_blank"
      rel="noopener noreferrer"
      id="floating-whatsapp"
      class="btn btn-whatsapp"
      aria-label="Contact via WhatsApp"
    >
      <svg width="28" height="28" viewBox="0 0 24 24" fill="currentColor">
        <path
          d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 00-3.48-8.413z"
        ></path>
      </svg>
    </a>

    {showChatWidget && <ChatWidget client:idle />}
    {showCommandMenu && <CommandMenu client:idle />}
    {showToaster && <Toaster client:load position="top-center" />}

    <script>
      import Lenis from "@studio-freight/lenis";
      import { translations } from "../i18n";

      const runtime = ((window as any).__cvRuntime ||= {});

      function shouldUseHeavyEffects() {
        const supportsFinePointer = window.matchMedia("(hover: hover) and (pointer: fine)").matches;
        return supportsFinePointer;
      }

      // --- CINEMATIC MOTION (LENIS) ---
      function initLenis() {
        if (runtime.lenis) {
          return;
        }

        const lenis = new Lenis({
          duration: 0.95,
          easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
          orientation: "vertical",
          gestureOrientation: "vertical",
          smoothWheel: true,
          wheelMultiplier: 0.85,
          touchMultiplier: 1.1,
          infinite: false,
        });

        runtime.lenis = lenis;
        (window as any).lenis = lenis;

        function raf(time: number) {
          lenis.raf(time);
          runtime.lenisRaf = requestAnimationFrame(raf);
        }

        runtime.lenisRaf = requestAnimationFrame(raf);

        // Reset scroll position on refresh
        window.history.scrollRestoration = "manual";

        if (runtime.anchorController) {
          runtime.anchorController.abort();
        }

        runtime.anchorController = new AbortController();
        document.addEventListener(
          "click",
          (e) => {
            const target = e.target as HTMLElement;
            const anchor = target.closest('a[href^="#"]') as
              | HTMLAnchorElement
              | null;
            if (!anchor) return;

            const targetId = anchor.getAttribute("href");
            if (!targetId || targetId === "#") return;

            e.preventDefault();
            lenis.scrollTo(targetId, { offset: -80 });
          },
          { signal: runtime.anchorController.signal },
        );
      }

      function teardownLenis() {
        if (runtime.anchorController) {
          runtime.anchorController.abort();
          runtime.anchorController = null;
        }

        if (runtime.lenisRaf) {
          cancelAnimationFrame(runtime.lenisRaf);
          runtime.lenisRaf = null;
        }

        if (runtime.lenis) {
          runtime.lenis.destroy();
          runtime.lenis = null;
          (window as any).lenis = null;
        }
      }

      // --- UNIFIED MOUSE TRACKING (rAF-gated) ---
      // ⚡ Perf: Consolidates cursor + spotlight into ONE mousemove listener
      // with requestAnimationFrame batching. Reduces style writes from
      // ~120/sec (2 handlers × 60 events) to at most 60/sec (1 per frame).
      // This cuts layout recalculations by ~50% during continuous mouse movement.
      function initMouseTracking() {
        if (runtime.mouseTrackingInitialized) {
          return;
        }

        const cursor = document.querySelector(
          ".custom-cursor",
        ) as HTMLElement | null;
        const spotlight = document.querySelector(
          ".mouse-spotlight",
        ) as HTMLElement | null;

        // Skip entirely if neither element exists
        if (!cursor && !spotlight) return;

        let mouseX = 0;
        let mouseY = 0;
        let rafScheduled = false;

        // Batched DOM update — runs at most once per paint frame
        function updatePositions() {
          if (cursor) {
            cursor.style.left = mouseX + "px";
            cursor.style.top = mouseY + "px";
          }
          if (spotlight) {
            spotlight.style.left = mouseX + "px";
            spotlight.style.top = mouseY + "px";
            spotlight.style.opacity = "1";
          }
          rafScheduled = false;
        }

        if (runtime.mouseController) {
          runtime.mouseController.abort();
        }

        runtime.mouseController = new AbortController();
        const mouseSignal = runtime.mouseController.signal;

        // Single listener for both cursor + spotlight
        window.addEventListener(
          "mousemove",
          (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            if (!rafScheduled) {
              rafScheduled = true;
              requestAnimationFrame(updatePositions);
            }
          },
          { passive: true, signal: mouseSignal },
        );

        // Spotlight fade-out on mouse leave
        if (spotlight) {
          window.addEventListener("mouseleave", () => {
            spotlight.style.opacity = "0";
          }, { signal: mouseSignal });
        }

        // Cursor click states (only if cursor exists)
        if (cursor) {
          document.addEventListener(
            "mousedown",
            () => cursor.classList.add("active"),
            { signal: mouseSignal },
          );
          document.addEventListener(
            "mouseup",
            () => cursor.classList.remove("active"),
            { signal: mouseSignal },
          );

          // Hover state for interactive elements
          document
            .querySelectorAll("a, button, .interactive, .magnetic")
            .forEach((el) => {
              el.addEventListener(
                "mouseenter",
                () => {
                  cursor.classList.add("hover");
                },
                { signal: mouseSignal },
              );
              el.addEventListener(
                "mouseleave",
                () => {
                  cursor.classList.remove("hover");
                },
                { signal: mouseSignal },
              );
            });
        }

        // Magnetic Hover Effect for Nav Links & Magnetic class
        document.querySelectorAll(".navbar a, .magnetic").forEach((el: any) => {
          el.addEventListener("mousemove", (e: MouseEvent) => {
            const rect = el.getBoundingClientRect();
            const x = e.clientX - rect.left - rect.width / 2;
            const y = e.clientY - rect.top - rect.height / 2;
            el.style.transform = `translate(${x * 0.3}px, ${y * 0.3}px)`;
            el.style.transition = "none";
          }, { signal: mouseSignal });
          el.addEventListener("mouseleave", () => {
            el.style.transform = `translate(0px, 0px)`;
            el.style.transition =
              "transform 0.5s cubic-bezier(0.23, 1, 0.32, 1)";
          }, { signal: mouseSignal });
        });

        runtime.mouseTrackingInitialized = true;
      }

      function teardownMouseTracking() {
        if (runtime.mouseController) {
          runtime.mouseController.abort();
          runtime.mouseController = null;
        }

        const cursor = document.querySelector(".custom-cursor") as HTMLElement | null;
        const spotlight = document.querySelector(".mouse-spotlight") as HTMLElement | null;
        if (cursor) {
          cursor.classList.remove("active", "hover");
        }
        if (spotlight) {
          spotlight.style.opacity = "0";
        }

        runtime.mouseTrackingInitialized = false;
      }

      // --- I18N LOGIC ---
      function updateTranslations(lang: "en" | "es") {
        runtime.currentLang = lang;
        document.documentElement.lang = lang;
        const elements = document.querySelectorAll("[data-i18n]");
        elements.forEach((el) => {
          const key = el.getAttribute("data-i18n");
          if (!key) return;

          const keys = key.split(".");
          let translation: any = translations[lang];

          for (const k of keys) {
            translation = translation[k];
            if (!translation) break;
          }

          if (translation) {
            const currentYear = new Date().getFullYear();
            const expYears = currentYear - 2014;

            let finalHtml = translation
              .replace("{year}", currentYear.toString())
              .replace("{years}", expYears.toString());

            if (el.tagName === "INPUT" || el.tagName === "TEXTAREA") {
              (el as HTMLInputElement | HTMLTextAreaElement).placeholder =
                finalHtml;
            } else {
              el.innerHTML = finalHtml;
            }
          }
        });

        // Update WhatsApp links
        const whatsappMsg =
          (translations[lang] as any).contact.whatsapp_msg ||
          (translations[lang] as any).nav.whatsapp_msg;
        const whatsappUrl = `https://wa.me/491789752993?text=${encodeURIComponent(whatsappMsg)}`;

        document.querySelectorAll('a[href*="wa.me"]').forEach((link: any) => {
          link.href = whatsappUrl;
        });

        // Update active state of language buttons
        document.querySelectorAll(".lang-btn").forEach((btn) => {
          btn.classList.toggle(
            "active",
            btn.getAttribute("data-lang") === lang,
          );
        });

        localStorage.setItem("preferred-lang", lang);

        // Dispatch event for components to react
        window.dispatchEvent(
          new CustomEvent("langChanged", { detail: { lang } }),
        );
      }

      function initI18n() {
        const savedLang = localStorage.getItem("preferred-lang") as
          | "en"
          | "es"
          | null;

        const initialLang =
          runtime.currentLang ||
          savedLang ||
          (navigator.language.startsWith("es") ? "es" : "en");

        updateTranslations(initialLang);

        if (runtime.i18nInitialized) {
          return;
        }

        // Language Toggle Setup
        document.addEventListener("click", (e) => {
          const target = e.target as HTMLElement;
          const langBtn = target.closest(".lang-btn") as HTMLElement | null;
          if (langBtn) {
            const lang = langBtn.getAttribute("data-lang") as "en" | "es";
            updateTranslations(lang);
          }
        });

        runtime.i18nInitialized = true;
      }

      // --- REFINED SCROLL & REVEAL LOGIC ---
      let revealObserver: IntersectionObserver;

      function initAnimations() {
        if (revealObserver) {
          revealObserver.disconnect();
        }

        revealObserver = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                entry.target.classList.add("visible");
                if (entry.target.classList.contains("reveal-once")) {
                  revealObserver.unobserve(entry.target);
                }
              }
            });
          },
          { threshold: 0.1, rootMargin: "0px 0px -50px 0px" },
        );

        document
          .querySelectorAll(
            ".reveal, .reveal-left, .reveal-right, .reveal-scale, .stagger-children",
          )
          .forEach((el) => revealObserver.observe(el));
      }

      // Scroll Handling
      let ticking = false;
      const progressEl = document.getElementById("scroll-progress");
      const parallaxLayers: HTMLElement[] = [];

      function cacheParallaxLayers() {
        parallaxLayers.length = 0;
        document.querySelectorAll(".parallax-layer").forEach((el) => {
          parallaxLayers.push(el as HTMLElement);
        });
      }

      function updateScroll() {
        const scrollY = window.scrollY;
        const docHeight =
          document.documentElement.scrollHeight - window.innerHeight;

        if (progressEl && docHeight > 0) {
          const progress = (scrollY / docHeight) * 100;
          progressEl.style.width = `${progress}%`;
        }

        // Performance: reuse a cached list of parallax layers instead of
        // querying the DOM on every scroll animation frame.
        parallaxLayers.forEach((el) => {
          const speed = parseFloat(el.dataset.speed || "0.2");
          el.style.transform = `translateY(${scrollY * speed}px)`;
        });

        ticking = false;
      }

      function onScroll() {
        if (!ticking) {
          window.requestAnimationFrame(updateScroll);
          ticking = true;
        }
      }

      // Initial Setup
      function setup() {
        const useHeavyEffects = shouldUseHeavyEffects();
        document.body.classList.toggle("heavy-effects", useHeavyEffects);

        if (!runtime.baseInitialized) {
          window.addEventListener("scroll", onScroll, { passive: true });
          runtime.baseInitialized = true;
        }

        // Performance: keep smooth scrolling and mouse effects for /about desktop only.
        if (useHeavyEffects) {
          initLenis();
          initMouseTracking();
        } else {
          teardownLenis();
          teardownMouseTracking();
        }

        initI18n();
        initAnimations();
        cacheParallaxLayers();
        updateScroll();
      }

      document.addEventListener("DOMContentLoaded", setup);
      document.addEventListener("astro:after-swap", setup);
    </script>
  </body><style is:global>
    @import "../styles/global.css";
  </style>
</html>
