---
import ChatWidget from "../components/ChatWidget";
import CommandMenu from "../components/CommandMenu";
import { Toaster } from "sonner";

interface Props {
  title?: string;
  description?: string;
  showChatWidget?: boolean;
  showCommandMenu?: boolean;
  showToaster?: boolean;
}

const {
  title = "Gabor Flandorffer — Senior Full-Stack Developer & Automation Specialist",
  description = "11+ years building scalable solutions with Python, Django, TypeScript, and automation tools. Based in Medellín.",
  showChatWidget = false,
  showCommandMenu = false,
  showToaster = false,
} = Astro.props;

const siteUrl = "https://gabor.flandorffer.com";
const canonicalUrl = new URL(Astro.url.pathname, siteUrl).toString();
const ogImageUrl = new URL("/images/profile/Gabor-Flandorffer-Profile.jpg", siteUrl).toString();

const personSchema = {
  "@context": "https://schema.org",
  "@type": "Person",
  name: "Gabor Flandorffer",
  url: siteUrl,
  image: ogImageUrl,
  jobTitle: "Senior Full-Stack Developer & Automation Specialist",
  email: "mailto:gabor285@gmail.com",
  telephone: "+49 1789752993",
  address: {
    "@type": "PostalAddress",
    addressLocality: "Medellín",
    addressCountry: "CO"
  },
  worksFor: {
    "@type": "Organization",
    name: "Freelance"
  },
  knowsAbout: [
    "Python",
    "Django",
    "Automation",
    "TypeScript",
    "CI/CD",
    "Backend Architecture"
  ],
  sameAs: [
    "https://github.com/codehimn",
    "https://linkedin.com/in/gabor-flandorffer/",
    "https://www.freelancer.com/u/Codehimn"
  ],
  description:
    "Senior Full-Stack Developer based in Medellín (UTC-5), available for global remote collaboration with adaptable working hours."
};
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{title}</title>
    <meta name="description" content={description} />
    <link rel="canonical" href={canonicalUrl} />

    <!-- SEO / OG Tags -->
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:type" content="website" />
    <meta property="og:url" content={canonicalUrl} />
    <meta property="og:image" content={ogImageUrl} />
    <meta property="og:site_name" content="Gabor Flandorffer" />
    <meta property="og:locale" content="en_US" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content={title} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:image" content={ogImageUrl} />
    <meta name="twitter:site" content="@codehimn" />
    <meta name="robots" content="index,follow,max-image-preview:large" />
    <meta name="author" content="Gabor Flandorffer" />
    <script type="application/ld+json" set:html={JSON.stringify(personSchema)}></script>

    <!-- Performance: Preconnect to font providers -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

    <!-- Performance: Preload critical fonts -->
    <link
        rel="preload"
        as="style"
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@400;500;600&family=Space+Grotesk:wght@600&display=swap"
        media="print"
        onload="this.media='all'"
      />
    <noscript
      ><link
        rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@400;500;600&family=Space+Grotesk:wght@600&display=swap"
      /></noscript
    >

    <link rel="icon" type="image/x-icon" href="/images/profile/favicon.ico" />
    <link rel="apple-touch-icon" href="/images/profile/favicon.ico" />
    <link rel="manifest" href="/manifest.json" />
  </head>
  <body>
    <!-- Skip to Content Link -->
    <a href="#main-content" class="skip-link" data-i18n="nav.skip_to_content">Skip to content</a>

    <!-- Custom Cursor -->
    <div class="custom-cursor" aria-hidden="true"></div>

    <!-- Mouse Spotlight -->
    <div class="mouse-spotlight" aria-hidden="true"></div>

    <!-- Scroll Progress Bar -->
    <div id="scroll-progress" class="scroll-progress" aria-hidden="true"></div>

    <slot />

    <!-- WhatsApp Floating Button -->
    <a
      href="https://wa.me/491789752993?text=Hi%20Gabor!%20I%20saw%20your%20portfolio%20and%20I'd%20like%20to%20chat."
      target="_blank"
      rel="noopener noreferrer"
      id="floating-whatsapp"
      class="btn btn-whatsapp"
      data-i18n-aria="contact.whatsapp_floating_label"
      aria-label="Contact via WhatsApp"
    >
      <svg width="28" height="28" viewBox="0 0 24 24" fill="currentColor">
        <path
          d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 00-3.48-8.413z"
        ></path>
      </svg>
    </a>

    {showChatWidget && <ChatWidget client:idle />}
    {showCommandMenu && <CommandMenu client:idle />}
    {showToaster && <Toaster client:load position="top-center" />}

    <script>
      import Lenis from "@studio-freight/lenis";
      import { translations } from "../i18n";

      const runtime = ((window as any).__cvRuntime ||= {});

      function shouldUseHeavyEffects() {
        const supportsFinePointer = window.matchMedia("(hover: hover) and (pointer: fine)").matches;
        return supportsFinePointer;
      }

      // --- CINEMATIC MOTION (LENIS) ---
      function initLenis() {
        if (runtime.lenis) {
          return;
        }

        const lenis = new Lenis({
          duration: 0.95,
          easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
          orientation: "vertical",
          gestureOrientation: "vertical",
          smoothWheel: true,
          wheelMultiplier: 0.85,
          touchMultiplier: 1.1,
          infinite: false,
        });

        runtime.lenis = lenis;
        (window as any).lenis = lenis;

        function raf(time: number) {
          lenis.raf(time);
          runtime.lenisRaf = requestAnimationFrame(raf);
        }

        runtime.lenisRaf = requestAnimationFrame(raf);

        // Reset scroll position on refresh
        window.history.scrollRestoration = "manual";

        if (runtime.anchorController) {
          runtime.anchorController.abort();
        }

        runtime.anchorController = new AbortController();
        document.addEventListener(
          "click",
          (e) => {
            const target = e.target as HTMLElement;
            const anchor = target.closest('a[href^="#"]') as
              | HTMLAnchorElement
              | null;
            if (!anchor) return;

            const targetId = anchor.getAttribute("href");
            if (!targetId || targetId === "#") return;

            e.preventDefault();
            lenis.scrollTo(targetId, {
              offset: -80,
              onComplete: () => {
                const targetEl = document.querySelector(targetId) as HTMLElement | null;
                if (targetEl) {
                  targetEl.focus({ preventScroll: true });
                }
              }
            });
          },
          { signal: runtime.anchorController.signal },
        );
      }

      function teardownLenis() {
        if (runtime.anchorController) {
          runtime.anchorController.abort();
          runtime.anchorController = null;
        }

        if (runtime.lenisRaf) {
          cancelAnimationFrame(runtime.lenisRaf);
          runtime.lenisRaf = null;
        }

        if (runtime.lenis) {
          runtime.lenis.destroy();
          runtime.lenis = null;
          (window as any).lenis = null;
        }
      }

      // --- UNIFIED MOUSE TRACKING (rAF-gated) ---
      // ⚡ Perf: Consolidates cursor + spotlight into ONE mousemove listener
      // with requestAnimationFrame batching. Reduces style writes from
      // ~120/sec (2 handlers × 60 events) to at most 60/sec (1 per frame).
      // This cuts layout recalculations by ~50% during continuous mouse movement.
      function initMouseTracking() {
        if (runtime.mouseTrackingInitialized) {
          return;
        }

        const cursor = document.querySelector(
          ".custom-cursor",
        ) as HTMLElement | null;
        const spotlight = document.querySelector(
          ".mouse-spotlight",
        ) as HTMLElement | null;

        // Skip entirely if neither element exists
        if (!cursor && !spotlight) return;

        let mouseX = 0;
        let mouseY = 0;
        let rafScheduled = false;

        // Batched DOM update — runs at most once per paint frame
        function updatePositions() {
          if (cursor) {
            cursor.style.left = mouseX + "px";
            cursor.style.top = mouseY + "px";
          }
          if (spotlight) {
            spotlight.style.left = mouseX + "px";
            spotlight.style.top = mouseY + "px";
            spotlight.style.opacity = "1";
          }
          rafScheduled = false;
        }

        if (runtime.mouseController) {
          runtime.mouseController.abort();
        }

        runtime.mouseController = new AbortController();
        const mouseSignal = runtime.mouseController.signal;

        // Optimization: Use a WeakMap to cache element bounds on enter.
        // This prevents layout thrashing during mousemove by avoiding
        // repeated getBoundingClientRect() calls.
        const rectCache = new WeakMap<Element, DOMRect>();

        let lastTarget: EventTarget | null = null;
        let currentMagnetic: HTMLElement | null = null;

        // Single listener for both cursor + spotlight
        window.addEventListener(
          "mousemove",
          (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;

            // ⚡ Bolt: Magnetic Hover Optimization.
            // Using delegation to identify magnetic targets and cached rects
            // to eliminate layout thrashing during continuous mouse movement.
            // Optimization: Only run closest() if the target actually changed.
            if (e.target !== lastTarget) {
              lastTarget = e.target;
              currentMagnetic = (e.target as HTMLElement)?.closest(".navbar a, .magnetic") as HTMLElement | null;
            }

            if (currentMagnetic) {
              let rect = rectCache.get(currentMagnetic);
              if (!rect) {
                rect = currentMagnetic.getBoundingClientRect();
                rectCache.set(currentMagnetic, rect);
              }
              const x = (e.clientX - rect.left - rect.width / 2) * 0.3;
              const y = (e.clientY - rect.top - rect.height / 2) * 0.3;
              currentMagnetic.style.transform = `translate(${x}px, ${y}px)`;
              currentMagnetic.style.transition = "none";
            }

            if (!rafScheduled) {
              rafScheduled = true;
              requestAnimationFrame(updatePositions);
            }
          },
          { passive: true, signal: mouseSignal },
        );

        // Spotlight fade-out on mouse leave
        if (spotlight) {
          window.addEventListener("mouseleave", () => {
            spotlight.style.opacity = "0";
          }, { signal: mouseSignal });
        }

        // Cursor click states (only if cursor exists)
        if (cursor) {
          document.addEventListener(
            "mousedown",
            () => cursor.classList.add("active"),
            { signal: mouseSignal },
          );
          document.addEventListener(
            "mouseup",
            () => cursor.classList.remove("active"),
            { signal: mouseSignal },
          );

          // ⚡ Bolt: Event Delegation Optimization.
          // Using a single mouseover listener on the document to handle cursor hover
          // states for all interactive elements. Correctly handles enter/leave.
          document.addEventListener("mouseover", (e) => {
            const target = e.target as HTMLElement;
            if (target?.closest?.("a, button, .interactive, .magnetic")) {
              cursor.classList.add("hover");
            } else {
              cursor.classList.remove("hover");
            }
          }, { signal: mouseSignal });

          document.addEventListener("mouseout", (e) => {
            const target = e.target as HTMLElement;
            // Cleanup magnetic state and cache on exit
            const magnetic = target?.closest?.(".navbar a, .magnetic") as HTMLElement | null;
            // ⚡ Bolt: Fix cleanup logic. Ensure we reset the transform ONLY when leaving
            // the actual magnetic element, not just when moving between its children.
            if (magnetic && (!e.relatedTarget || (e.relatedTarget as HTMLElement).closest?.(".navbar a, .magnetic") !== magnetic)) {
              magnetic.style.transform = "translate(0,0)";
              magnetic.style.transition = "transform 0.5s cubic-bezier(0.23, 1, 0.32, 1)";
              rectCache.delete(magnetic);
            }
          }, { signal: mouseSignal });
        }

        runtime.mouseTrackingInitialized = true;
      }

      function teardownMouseTracking() {
        if (runtime.mouseController) {
          runtime.mouseController.abort();
          runtime.mouseController = null;
        }

        const cursor = document.querySelector(".custom-cursor") as HTMLElement | null;
        const spotlight = document.querySelector(".mouse-spotlight") as HTMLElement | null;
        if (cursor) {
          cursor.classList.remove("active", "hover");
        }
        if (spotlight) {
          spotlight.style.opacity = "0";
        }

        runtime.mouseTrackingInitialized = false;
      }

      // --- I18N LOGIC ---
      function updateTranslations(lang: "en" | "es") {
        runtime.currentLang = lang;
        document.documentElement.lang = lang;

        // ⚡ Bolt: Cache current year and experience years once outside the loops.
        const currentYear = new Date().getFullYear().toString();
        const expYears = (Number(currentYear) - 2014).toString();

        const resolveTranslationForLang = (key: string, targetLang: "en" | "es") => {
          const keys = key.split(".");
          let translation: any = translations[targetLang];

          for (const k of keys) {
            translation = translation?.[k];
            if (translation === undefined || translation === null) {
              return null;
            }
          }

          return translation;
        };

        const resolveTranslation = (key: string) => resolveTranslationForLang(key, lang);

        const elements = document.querySelectorAll("[data-i18n]");
        elements.forEach((el) => {
          const key = el.getAttribute("data-i18n");
          if (!key) return;

          const translation = resolveTranslation(key);

          if (translation) {
            let finalHtml = translation
              .replace("{year}", currentYear)
              .replace("{years}", expYears);

            if (el.tagName === "INPUT" || el.tagName === "TEXTAREA") {
              (el as HTMLInputElement | HTMLTextAreaElement).placeholder =
                finalHtml;
            } else {
              el.innerHTML = finalHtml;
            }
          }
        });

        document.querySelectorAll("[data-i18n-aria]").forEach((el) => {
          const key = el.getAttribute("data-i18n-aria");
          if (!key) return;

          const translation = resolveTranslation(key);
          if (translation) {
            let finalLabel = translation
              .replace("{year}", currentYear)
              .replace("{years}", expYears);

            el.setAttribute("aria-label", finalLabel);
          }
        });

        document.querySelectorAll("[data-i18n-tags]").forEach((el) => {
          const key = el.getAttribute("data-i18n-tags");
          if (!key) return;

          const tags = resolveTranslation(key);
          if (!Array.isArray(tags)) return;

          el.innerHTML = tags
            .map(
              (tag: string) =>
                `<span class="tag">${String(tag)
                  .replace(/&/g, "&amp;")
                  .replace(/</g, "&lt;")
                  .replace(/>/g, "&gt;")}</span>`,
            )
            .join("");
        });

        document.querySelectorAll("[data-i18n-href]").forEach((el) => {
          const key = el.getAttribute("data-i18n-href");
          if (!key) return;

          const hrefValue =
            resolveTranslation(key) || resolveTranslationForLang(key, "en");
          if (typeof hrefValue !== "string") return;

          if (hrefValue.trim()) {
            el.setAttribute("href", hrefValue);
            if (el.hasAttribute("data-hide-if-empty-href")) {
              (el as HTMLElement).style.display = "";
            }
          } else {
            el.removeAttribute("href");
            if (el.hasAttribute("data-hide-if-empty-href")) {
              (el as HTMLElement).style.display = "none";
            }
          }
        });

        // Update WhatsApp links
        const whatsappMsg =
          (translations[lang] as any).contact.whatsapp_msg ||
          (translations[lang] as any).nav.whatsapp_msg;
        const whatsappUrl = `https://wa.me/491789752993?text=${encodeURIComponent(whatsappMsg)}`;

        document.querySelectorAll('a[href*="wa.me"]').forEach((link: any) => {
          link.href = whatsappUrl;
        });

        // Update active state of language buttons
        document.querySelectorAll(".lang-btn").forEach((btn) => {
          const isActive = btn.getAttribute("data-lang") === lang;
          btn.classList.toggle("active", isActive);
          btn.setAttribute("aria-pressed", isActive ? "true" : "false");
        });

        localStorage.setItem("preferred-lang", lang);

        // Dispatch event for components to react
        window.dispatchEvent(
          new CustomEvent("langChanged", { detail: { lang } }),
        );
      }

      function initI18n() {
        const savedLang = localStorage.getItem("preferred-lang") as
          | "en"
          | "es"
          | null;

        const initialLang =
          runtime.currentLang ||
          savedLang ||
          (navigator.language.startsWith("es") ? "es" : "en");

        updateTranslations(initialLang);

        if (runtime.i18nInitialized) {
          return;
        }

        // Language Toggle Setup
        document.addEventListener("click", (e) => {
          const target = e.target as HTMLElement;
          const langBtn = target.closest(".lang-btn") as HTMLElement | null;
          if (langBtn) {
            const lang = langBtn.getAttribute("data-lang") as "en" | "es";
            updateTranslations(lang);
          }
        });

        runtime.i18nInitialized = true;
      }

      // --- REFINED SCROLL & REVEAL LOGIC ---
      let revealObserver: IntersectionObserver;

      function initAnimations() {
        if (revealObserver) {
          revealObserver.disconnect();
        }

        revealObserver = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                entry.target.classList.add("visible");
                if (entry.target.classList.contains("reveal-once")) {
                  revealObserver.unobserve(entry.target);
                }
              }
            });
          },
          { threshold: 0.1, rootMargin: "0px 0px -50px 0px" },
        );

        document
          .querySelectorAll(
            ".reveal, .reveal-left, .reveal-right, .reveal-scale, .stagger-children",
          )
          .forEach((el) => revealObserver.observe(el));
      }

      // Scroll Handling
      let ticking = false;
      const progressEl = document.getElementById("scroll-progress");
      const parallaxLayers: { el: HTMLElement; speed: number }[] = [];

      function cacheParallaxLayers() {
        parallaxLayers.length = 0;
        document.querySelectorAll(".parallax-layer").forEach((el) => {
          const htmlEl = el as HTMLElement;
          parallaxLayers.push({
            el: htmlEl,
            speed: parseFloat(htmlEl.dataset.speed || "0.2"),
          });
        });
      }

      function updateScroll() {
        const scrollY = window.scrollY;
        const docHeight =
          document.documentElement.scrollHeight - window.innerHeight;

        if (progressEl && docHeight > 0) {
          const progress = (scrollY / docHeight) * 100;
          progressEl.style.width = `${progress}%`;
        }

        // Performance: reuse a cached list of parallax layers instead of
        // querying the DOM on every scroll animation frame.
        // ⚡ Bolt: Also cached the 'speed' value to eliminate repeated parseFloat()
        // and dataset lookups during scroll, making the animation smoother.
        parallaxLayers.forEach(({ el, speed }) => {
          el.style.transform = `translateY(${scrollY * speed}px)`;
        });

        ticking = false;
      }

      function onScroll() {
        if (!ticking) {
          window.requestAnimationFrame(updateScroll);
          ticking = true;
        }
      }

      // Initial Setup
      function setup() {
        const useHeavyEffects = shouldUseHeavyEffects();
        document.body.classList.toggle("heavy-effects", useHeavyEffects);

        if (!runtime.baseInitialized) {
          window.addEventListener("scroll", onScroll, { passive: true });
          runtime.baseInitialized = true;
        }

        // Performance: keep smooth scrolling and mouse effects for /about desktop only.
        if (useHeavyEffects) {
          initLenis();
          initMouseTracking();
        } else {
          teardownLenis();
          teardownMouseTracking();
        }

        initI18n();
        initAnimations();
        cacheParallaxLayers();
        updateScroll();
      }

      document.addEventListener("DOMContentLoaded", setup);
      document.addEventListener("astro:after-swap", setup);
    </script>
  </body><style is:global>
    @import "../styles/global.css";
  </style>
</html>
